package lockfile_test

import (
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/donaldgifford/forge/internal/lockfile"
)

func TestWriteAndRead_RoundTrip(t *testing.T) {
	t.Parallel()

	dir := t.TempDir()
	path := filepath.Join(dir, lockfile.FileName)

	now := time.Now().Truncate(time.Second).UTC()
	original := &lockfile.Lockfile{
		Blueprint: lockfile.BlueprintRef{
			RegistryURL: "github.com/acme/blueprints",
			Name:        "go-api",
			Path:        "go/api",
			Ref:         "v1.0.0",
			Commit:      "abc123",
		},
		CreatedAt:    now,
		LastSynced:   now,
		ForgeVersion: "0.1.0",
		Variables: map[string]any{
			"project_name": "my-api",
			"go_module":    "github.com/example/my-api",
			"use_grpc":     false,
			"port":         8080,
		},
		Defaults: []lockfile.DefaultEntry{
			{Path: ".editorconfig", Source: "registry-default", Strategy: "overwrite"},
			{Path: ".golangci.yml", Source: "category-default", Strategy: "overwrite"},
		},
		ManagedFiles: []lockfile.ManagedFileEntry{
			{Path: "Makefile", Strategy: "merge", SyncedCommit: "abc123"},
		},
		Tools: []lockfile.ToolEntry{
			{Name: "golangci-lint", Version: "1.62.2", Source: "github-release"},
		},
	}

	err := lockfile.Write(path, original)
	require.NoError(t, err)

	loaded, err := lockfile.Read(path)
	require.NoError(t, err)

	assert.Equal(t, original.Blueprint, loaded.Blueprint)
	assert.Equal(t, original.ForgeVersion, loaded.ForgeVersion)
	assert.Equal(t, original.Variables["project_name"], loaded.Variables["project_name"])
	assert.Equal(t, original.Variables["go_module"], loaded.Variables["go_module"])
	assert.Len(t, loaded.Defaults, 2)
	assert.Len(t, loaded.ManagedFiles, 1)
	assert.Len(t, loaded.Tools, 1)
	assert.Equal(t, "golangci-lint", loaded.Tools[0].Name)
}

func TestWrite_ContainsHeader(t *testing.T) {
	t.Parallel()

	dir := t.TempDir()
	path := filepath.Join(dir, lockfile.FileName)

	err := lockfile.Write(path, &lockfile.Lockfile{
		ForgeVersion: "0.1.0",
	})
	require.NoError(t, err)

	data, err := os.ReadFile(path)
	require.NoError(t, err)

	content := string(data)
	assert.Contains(t, content, "DO NOT EDIT MANUALLY")
	assert.Contains(t, content, "Generated by forge")
}

func TestRead_NotFound(t *testing.T) {
	t.Parallel()

	_, err := lockfile.Read("/nonexistent/.forge-lock.yaml")
	require.Error(t, err)
	assert.Contains(t, err.Error(), "reading lockfile")
}

func TestRead_InvalidYAML(t *testing.T) {
	t.Parallel()

	dir := t.TempDir()
	path := filepath.Join(dir, lockfile.FileName)

	require.NoError(t, os.WriteFile(path, []byte("invalid: [yaml: {{"), 0o644))

	_, err := lockfile.Read(path)
	require.Error(t, err)
	assert.Contains(t, err.Error(), "parsing lockfile")
}

func TestWrite_EmptyLockfile(t *testing.T) {
	t.Parallel()

	dir := t.TempDir()
	path := filepath.Join(dir, lockfile.FileName)

	err := lockfile.Write(path, &lockfile.Lockfile{})
	require.NoError(t, err)

	loaded, err := lockfile.Read(path)
	require.NoError(t, err)

	assert.Empty(t, loaded.Defaults)
	assert.Empty(t, loaded.ManagedFiles)
	assert.Empty(t, loaded.Tools)
}
