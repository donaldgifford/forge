// Package lockfile manages .forge-lock.yaml state tracking for scaffolded projects.
package lockfile

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"os"
	"time"

	"gopkg.in/yaml.v3"
)

const (
	// FileName is the standard lockfile name.
	FileName = ".forge-lock.yaml"

	// header is prepended to written lockfile content.
	header = "# .forge-lock.yaml â€” DO NOT EDIT MANUALLY\n# Generated by forge. Changes will be overwritten on sync.\n"
)

// Lockfile tracks the provenance, variables, and sync state of a scaffolded project.
type Lockfile struct {
	Blueprint    BlueprintRef       `yaml:"blueprint"`
	CreatedAt    time.Time          `yaml:"created_at"`
	LastSynced   time.Time          `yaml:"last_synced"`
	ForgeVersion string             `yaml:"forge_version"`
	Variables    map[string]any     `yaml:"variables"`
	Defaults     []DefaultEntry     `yaml:"defaults,omitempty"`
	ManagedFiles []ManagedFileEntry `yaml:"managed_files,omitempty"`
}

// BlueprintRef identifies the source blueprint.
type BlueprintRef struct {
	RegistryURL string `yaml:"registry_url"`
	Name        string `yaml:"name"`
	Path        string `yaml:"path"`
	Ref         string `yaml:"ref,omitempty"`
	Commit      string `yaml:"commit,omitempty"`
}

// DefaultEntry tracks an inherited default file.
type DefaultEntry struct {
	Path         string `yaml:"path"`
	Source       string `yaml:"source"`
	Strategy     string `yaml:"strategy"`
	Hash         string `yaml:"hash,omitempty"`
	SyncedCommit string `yaml:"synced_commit,omitempty"`
}

// ManagedFileEntry tracks a file managed for ongoing sync.
type ManagedFileEntry struct {
	Path         string `yaml:"path"`
	Strategy     string `yaml:"strategy"`
	Hash         string `yaml:"hash,omitempty"`
	SyncedCommit string `yaml:"synced_commit,omitempty"`
}

// ContentHash computes the SHA256 hash of content in the format "sha256:<hex>".
func ContentHash(content []byte) string {
	h := sha256.Sum256(content)
	return "sha256:" + hex.EncodeToString(h[:])
}

// Write marshals the lockfile to YAML and writes it to the given path.
func Write(path string, lock *Lockfile) error {
	data, err := yaml.Marshal(lock)
	if err != nil {
		return fmt.Errorf("marshaling lockfile: %w", err)
	}

	content := []byte(header + string(data))

	if err := os.WriteFile(path, content, 0o644); err != nil {
		return fmt.Errorf("writing lockfile %s: %w", path, err)
	}

	return nil
}

// Read reads and parses a lockfile from the given path.
func Read(path string) (*Lockfile, error) {
	data, err := os.ReadFile(path) //nolint:gosec // lockfile path comes from known project directories
	if err != nil {
		return nil, fmt.Errorf("reading lockfile %s: %w", path, err)
	}

	var lock Lockfile
	if err := yaml.Unmarshal(data, &lock); err != nil {
		return nil, fmt.Errorf("parsing lockfile %s: %w", path, err)
	}

	return &lock, nil
}
